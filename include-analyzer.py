#!/usr/bin/python3
# Copyright 2020 (c) CNRS
# A quick and (very) dirty tool to analyze and format in html the output of gcc used with it is used with the -H option.
# The idea is to be able to navigate easily in the dependency graph to spot and fix un-needed dependencies.
# While "include-what-you-use" detect not needed includes and can refactor the code to replace types with their forward dependencies 
# it is limited in its ability to refactor the code (eg: will not move definition from .h to a .cpp) to increase the amount of 
# not-needed includes. So I made this include analyzer to helps developper to detect weird inclusion pattern, ones indicating, 
# code coupling so that once refactored "Include what you use can do a good job" 
#  
# Author: damien.marchal@univ-lille.fr

import sys
import re
import os
from collections import deque
import pprint

# I know this is bad but I have no time to fix this so I share that as is. 
# This is mostly there to shorten/filter the path in output and input. 
fixPathPrefix = "/home/dmarchal/projects/DEFROST/dev/sofa3/build/"
sofaPrefix = "/home/dmarchal/projects/DEFROST/dev/sofa3/"

if len(sys.argv) != 2:
    print("USAGE: include-analyzer.py inputFileName.txt > outFile.html")
    print("The input file is what is generated by gcc when used with the -H option (so you must compile with -H option set)")
    sys.exit(-1) 

fileName = sys.argv[1]

def isRejectedLibrary(name):
    for libName in ["/usr/include","/opt","usr/lib/"]:
        if libName in name:
            return True
    return False
    
def isInSelectedLibrary(name):
    for libName in ["eigen"]:
        if libName in name:
            return True
    return False
    
skipSystemIncludes = True
includes = {}

def add_include_reference(includeName, includedBy):
    #print("SET", includeFileName, " in", includedBy)

    if isRejectedLibrary(includeName) or isRejectedLibrary(includedBy):
        if not isInSelectedLibrary(includeName) and not isInSelectedLibrary(includedBy):
            return
   
    includeName = os.path.abspath(includeName)
    includedBy = os.path.abspath(includedBy)

    if includeName not in includes:
        size = 0
        if os.path.exists(includeName):
            size = os.stat(includeName).st_size 
    
        includes[includeName] = {
            "sources": {},
            "totalInclusion" : 0,
             "size" : size
            }

    if includedBy not in includes[includeName]["sources"]:
        includes[includeName]["sources"][includedBy] = 0
    includes[includeName]["sources"][includedBy] += 1
    
def computeInclusionCount(includes):
    totalInclusion = 0
    for key, entry in includes.items():
        inclusion = 0
        for ksrc, count in entry["sources"].items():
            inclusion += count
            totalInclusion += count
        includes[key]["inclusionCount"] = inclusion
        includes[key]["loadedSize"] = entry["size"] * float(inclusion) / (1024.0 * 1024.0)
    return float(totalInclusion)

searchHpp=re.compile("(\.+) (.*\.h)$")    
searchNoH=re.compile("(\.+) (.*[^\.])$")
searchInl=re.compile("(\.+) (.*\.inl)$")
searchCpp=re.compile(".* Building CXX object (.*)$")
with open(fileName,"r") as inputfile:
     currentParent = "XX"
     currentDepth = 0
     stack = deque()

     for cnt, line in enumerate(inputfile):
        #print("LINE ", line)
        
        line = line.replace("\n", "")
        result = searchCpp.match(line)
        if result:
            stack.append(result.groups()[0])
            
            continue 
                        
        result = searchHpp.match(line)
        if not result:
            result = searchInl.match(line)
            if not result:
                result = searchNoH.match(line)
            
        if result:
            depth = len(result.groups()[0])
            includeFileName = result.groups()[1]

            if not includeFileName.startswith("/"):
                includeFileName = fixPathPrefix + includeFileName

            ###
            # . toto.h
            # .. tata.h
            # .. tutu.h
            # ... tonton.h
            # . twtw.h

            if depth < len(stack): 
                #print("POP >", depth, len(stack))
                while depth < len(stack):
                    l = stack.pop()
                    #print("POP ENTRY", l)
                stack.append(includeFileName)
                #print("VALUE... ", currentParent)
                add_include_reference(includeFileName, stack[-2])
                
            elif depth > len(stack)-1:
                #print("PUSH <", depth, len(stack), stack, " <- ", includeFileName)
                add_include_reference(includeFileName, stack[-1])
                stack.append(includeFileName)
                #currentDepth += 1
                #currentParent = includeFileName 
                

            else:
                #print("EQUAL =")
                add_include_reference(includeFileName, stack[-1])
               

def removePrefix(prefix, fromString):
    if fromString.startswith(prefix):
        return fromString[len(prefix):]
    return fromString
    
def dumpHtml(includes):
    global sofaPrefix
    print("<HTML><BODY>")
    for file, entry in sorted(includes.items(), reverse=True, key=lambda x: x[1]["inclusionCount"]):
        #entry = includes[file]
        file = removePrefix(sofaPrefix, fromString=file)
        print("File <a id='"+file+"'>"+file+"</a> loaded "+str(entry["inclusionCount"])+" times. <br>")
        print("<ul>")
        for includedBy, count in sorted(entry["sources"].items(), reverse=True, key=lambda x: x[1]):
           includedBy = removePrefix(sofaPrefix, fromString=includedBy)
           print(" <li> "+str(count)+" includes are from <a href='#"+includedBy+"'>"+includedBy+"</a></li>")
        print("</ul>")
    print("</BODY></HTML>")

                
computeInclusionCount(includes)
#pprint.pprint(includes)
dumpHtml(includes)

print("Number of included files:", len(includes))
print("Number of inclusions:", computeInclusionCount(includes), " ratio:", computeInclusionCount(includes)/len(includes))
        

